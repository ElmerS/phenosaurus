# Import Django related libraries and functions
from django.shortcuts import render, render_to_response
from django.http import HttpResponse
from django_pandas.io import read_frame
from django.contrib.auth.decorators import login_required
from django.db.models import Q, Avg, Max, Min	# To find min and max values in QS
from django import forms

# Import other custom phenosaurus functions
import models as db
import custom_functions as cf
import plots
import globalvars as gv
import forms

# Other general libraries
import pandas as pd
import numpy as np
import operator
from collections import namedtuple


def get_authorized_screens(request):
	# Because all data is public in this version of Phenosaurs, rather than quering the group ID's (gids) of the
	# current user we, the gids variable is assigned the public group to which all the public screens belong
	gids = [gv.public_group_id]
	# For user identification replace it with the following line
	#gids = request.user.groups.values_list('id',flat=True)
	authorized_screens = cf.get_authorized_screens_from_gids(gids)
	return authorized_screens

def landing(request):
	return render(request, 'uniqueref/landing.html', {})

def help(request):
	return render(request, "uniqueref/help.html", {})

def updates(request):
	updates = cf.get_qs_updates().order_by('-date')
	return render(request, "uniqueref/updates.html", {'updates':updates})

def listgenes(request):
	data = cf.list_genes() # Generate the table
	return render(request, "uniqueref/listgenes.html", {'data':data})
	

def IPSFishtail(request):
	# To render the form, send it the data to display the right options based on the user and use a GET request to obtain the results
	authorized_screens = list(get_authorized_screens(request)) # Check user groups to see which screen are allowed to be seen
	strigefied_authorized_screens=','.join(str(i) for i in authorized_screens)	# Convert list if screens that user is allowed to see to string
	filter = forms.SingleIPSPlotForm(input=strigefied_authorized_screens) # First load the filter from .form

	# Pull the data from the URL upon submission of the form
	screenid = request.GET.get('screen', '') 		# Screenid is parsed as a number packed in a string
	oca = request.GET.get('oca', '')				# Gather on-click-action
	giventextsize = request.GET.get('textsize', '')	# This is for determining the size of labels next to a gene
	givenpvalue = request.GET.get('pvalue', '') 	# The p-value cutoff for coloring
	sag = request.GET.get('sag','') 				# Do all genes need to be labeled?
	showtable = request.GET.get('showtable', '')	# Whether a table should be drawn with raw values

	# First check if the user has given a screen as input, otherwise raise an error
	if screenid=='':
		error = gv.formerror
		return render(request, "uniqueref/singlescreen.html", {'filter':filter, 'error':error})

	# Then check if screen requested by the user is actually a screen that he/she is allowed to see.
	# This may seem a bit over the top but a user may have manually changed the URL and has entered a screenid in it of
	# screen that does not belong to this user. Although it doesn't really matter because validation always occurs too
	# prior to quering the database and not solely by this form, it is nice to know the user isn't trying to sneak around
	elif (int(screenid) in authorized_screens):
		textsize = cf.set_textsize(giventextsize)	# Check the textsize given by the user
		pvcutoff = cf.set_pvalue(givenpvalue)		# Check the p-value given by the user
		title = cf.title_single_screen_plot(screenid, authorized_screens)
		df,legend = cf.generate_df_pips(screenid, pvcutoff, authorized_screens)
		script,div = plots.fishtail(title, df, sag, oca, textsize, authorized_screens) # The script and div that is generated by the pfishtailplot function and contains all plotting info
		# If the user want's to display a table of all datapoints call generate_ips_tophits function to make the table
		if showtable == "on":
			data = cf.generate_ips_tophits_list(df)
			return render(request, "uniqueref/singlescreen.html", {'the_script':script, 'the_div':div, 'filter':filter, 'data':data})
		else:
			return render(request, "uniqueref/singlescreen.html", {'the_script':script, 'the_div':div, 'filter':filter})

	# If previous statement returns false, the user has manually modified the GET request in an illegal way. Serve an error.
	elif (screenid in authorized_screens)==False:
		error = gv.request_screen_authorization_error
		return render(request, "uniqueref/singlescreen.html", {'filter':filter, 'error':error})

	# And finally, just show the filter in case the user just arrived on this page and hasn't submitted the form yet
	else:
		error = gv.formerror
		return render(request, "uniqueref/singlescreen.html", {'filter':filter, 'error':error})


def opengenefinder(request):
	# Call the search- and customization form
	# Check user groups to see which screen are allowed to be seen by the user
	authorized_screens = list(get_authorized_screens(request)) # Check user groups to see which screen are allowed to be seen
	strigefied_authorized_screens=','.join(str(i) for i in authorized_screens)	# Convert list if screens that user is allowed to see to string
	filter = forms.OpenGeneFinderForm(input=strigefied_authorized_screens) # First load the filter from .forms

	# Pull the data from the URL upon submission of the form
	screenids = request.GET.getlist('screens', '') 		# The screens for which the MI-values needs to be plotted
	genenamesstring = request.GET.get('genes', '') 		# The given list of genes, presented as a string
	givenpvalue = request.GET.get('pvalue', '') 		# The p-value cutoff for coloring
	plot_width = request.GET.get('plot_width', '')		# The width of the plot

	# First check if the user has given a screen as input, otherwise raise an error
	if ((not genenamesstring) or (not screenids)):
		error=gv.formerror
		return render(request, 'uniqueref/opengenefinder.html', {'filter':filter, 'error':error})

	# Then check if screens requested by the user are actually screens that he/she is allowed to see.
	# This may seem a bit over the top but a user may have manually changed the URL and has entered a screenid in it
	# of a screen that does not belong to this user. Although it doesn't really matter because validation always occurs
	# prior to quering the database as well and not solely by this form, it is nice to know the user isn't trying to
	# sneak around. First call set_screenids to test whether the given list can be converted into a list of ints.
	# Finally, also check if the length of the returned array of set_screenids if the list is empty it means
	# the conversion into a list of ints failed
	elif (set(cf.set_screenids(screenids)).issubset(set(authorized_screens)) and (len(cf.set_screenids(screenids))>0)):
		pvcutoff = cf.set_pvalue(givenpvalue) 								# Check the p-value given by the user
		screenids_array = cf.set_screenids(screenids)					# Convert list of screens to int
		genes_array, error = cf.create_genes_array(genenamesstring) 		# Check from given genes which are in DB

		# Need some safety mechanism to prevent people plotting more than a certain numer (max_graphs) at the same time... that's just too much work
		if (len(genes_array)>gv.max_geneplots):
			error = gv.max_graphs_warning		# This may overwrite the error message from cf.create_genes_array but that isn't relevant
			return render(request, 'uniqueref/opengenefinder.html', {'filter':filter, 'error':error})
		# Besides people trying to plot more than 50 genes at the same time, there might be people who cannot spell or
		# enter a list of genes of which none are in the database. The all the above criteria are met, yet a plot cannot
		# be drawn. Raise an error. The error is already generated by cf.create_genes_array.
		elif (len(genes_array)==0):
			return render(request, 'uniqueref/opengenefinder.html', {'filter': filter, 'error': error})
		else:
			df = cf.get_df_for_multiple_geneplots(genes_array, screenids_array, pvcutoff, authorized_screens)
			plotlist = plots.geneplot(df, screenids_array, pvcutoff, plot_width, authorized_screens) # Call single_gene_plots to create a list of plotting objects
			script, div = plots.vertical_geneplots_layout(plotlist)
			return render(request, 'uniqueref/opengenefinder.html', {'the_script':script, 'the_div':div, 'filter':filter, 'error':error})
	else:
		error = gv.request_screen_authorization_error
		return render(request, 'uniqueref/opengenefinder.html', {'filter':filter, 'error':error})